<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Pregel+</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <style>
    body {
        margin-top: 60px;
    }
    </style>
	<script src="artDialog/artDialog.js?skin=black"></script>		<script>			(function (config) {  			config['lock'] = true;  			config['fixed'] = true;  			config['okVal'] = 'CLOSE';			// [more..]  		})(art.dialog.defaults);		var vdel_note = '<p><b>[NOTE]</b> <i><u>We use \"Implementation Note\" to discuss system implementaion details, which is of interest to people who want to change/extend the system; you may skip it if you are only interested in using the system to implement application code.</u></i></p>\		<p>Here, we briefly explain where the system deletes vertices, using the basic mode for illustration. Consider the <i>Worker</i> class in \"basic/Worker.h\", and consider the function <i>Worker::sync_graph()</i>. During data loading, each worker process reads a fraction of the input and converts the lines to vertices. However, a vertex <i>v</i> loaded by a worker <i>w<sub>i</sub></i> may have <i>hash(v) = w<sub>j</sub></i>, and thus, <i>w<sub>i</sub></i> needs to send <i>v</i> to <i>w<sub>j</sub></i> before graph computing. In other words, workers need to exchange vertices to ensure that they hold the vertices that they are responsible for. This is done by <i>Worker::sync_graph()</i>, where vertex exchange is done by the <i>all_to_all()</i> function (defined in \"utils/communication.h\") and vertices directed at other workers are deleted after being sent. Please check the function code for the details.</p>\		<p>The second place where the system deletes vertices is in the destructor of the <i>Worker</i> class. Please check the function code for the details.';		var vload_note = '<p>Here, we briefly explain how the system calls <i>Worker::toVertex(line)</i> to load the vertices. In HDFS, a graph is stored as a folder of files, where each file contains many lines each representing a vertex. During graph loading, the master will assign the files evenly to the workers, and each worker calls <i>Worker::load_graph(inpath)</i> (see \"basic/Worker.h\") for each file assigned. In <i>Worker::load_graph(inpath)</i>, the user-defined <i>toVertex(line)</i> function is called for each line of the file to parse it into a vertex object, which is appended to the worker\'s vertex set <i>Worker::vertexes</i>.</p>'		var vdump_note = '<p>Here, we briefly explain how the system calls <i>Worker::toline(v, writer)</i> to dump the vertices to HDFS. The result of a Pregel+ job is written to a user-specified output folder in HDFS, where each worker process calls <i>toline(v, writer)</i> for each vertex <i>v</i> it is responsible for, and writes the information of <i>v</i> to a file under the output folder. This is done by function <i>Worker::dump_partition(outpath)</i>. Worker <i>i</i> writes to files \"part_i_j\", where <i>j</i> = 1, 2, ... In \"utils/ydhdfs.h\", we define \"HDFS_BLOCK_SIZE\" to be 8M, and if the current file worker <i>i</i> is writing (let it be \"part_i_j\") has size exceeding \"HDFS_BLOCK_SIZE\", worker <i>i</i> creates a new file (i.e. \"part_i_(j+1)\") to write vertex information. The file splitting is automatically handled by class <i>BufferedWriter</i> defined in \"utils/ydhdfs.h\".</p>'		var combiner_note = '<p>The <i>Combiner</i> class is defined in \"utils/Combiner.h\", and the mentioned system-level message combining operation is implemented in <i>Vecs::combiner()</i> of \"utils/vecs.h\", which is called by the message buffer\'s <i>MessageBuffer::combine()</i> function defined in \"basic/MessageBuffer.h\".</p>\		<p>To achieve better performance, the actual implementation is actually a little bit different from the logic described. When vertices send messages, the messages are simply appended to the end of the message buffer; before being sent, the messages are sorted by the target vertex ID to form groups, and messages in each group are combined into one message using the specified combining function.</p>'		</script>
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Pregel+</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="download.html">Download</a>
					</li>
					<li><a href="documentation.html">Documentation</a>
					</li>
					<li><a href="publications.html">Publications</a>
					</li>
					<li><a href="team.html">Team</a>
					</li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-12">
                <h1>Pregel+ Architecture Overview</h1>
            </div>
        </div>		<h2>Pregel+ Architecture</h2>				<p>A diagram of the architecture of Pregel+ is shown in the figure below. Pregel+ is implemented in C/C++ as a group of header files, and users only need to include the necessary base classes and implement the application logic in their subclasses. A Pregel+ application program is compiled using GCC, preferably with -O2 option enabled. Click <a href="console.html">here</a> to see how to run a Pregel+ program in your cluster.</p>		
        <p>&nbsp;</p>
        <div align="center"><img src="figs/arch.png" width="640px"></img></div>
		<p>&nbsp;</p>				<p>Pregel+ communicates with HDFS (e.g. for graph loading and result dumping) through <a href="http://hadoop.apache.org/docs/r1.2.1/libhdfs.html" target="_blank">libhdfs</a>, a JNI based C API for HDFS. Each computing unit (or, worker) of Pregel+ is simply an MPI process and communications are implemented using MPI communication primitives. One may deploy Pregel+ with any Hadoop and MPI version, such as Hadoop 1.2.1 and MPICH 3.0.4.</p>				<p>Unlike Pregel, Pregel+ also makes the master a worker, and the task of fault recovery can be implemented by a script as follows. The script loops a Pregel+ job, which runs for at most Î” supersteps before dumping the intermediate results to HDFS. Meanwhile, the script also monitors the cluster condition. If a machine is down, the script kills the current job and restarts another job loading the latest intermediate results from HDFS. Fault tolerance is achieved by the data replication in HDFS.</p>		<p>&nbsp;</p>				<h2>User-Defined Classes</h2>				<p>In this web page, we just provide a high-level description of Pregel+'s base classes. Users need to subclass them with their template arguments properly specified in the application code. Click <a href="api.html">here</a> to check the detailed programming interface.</p>				<h4><u>Vertex</u></h4>				<p>The <b>Vertex</b> class has an abstract <b>compute()</b> function, where users implement their vertex-centric computing logic. An <b>Vertex</b> object maintains three fields: a vertex ID of type <b>&lt;I&gt;</b>, a vertex value type <b>&lt;V&gt;</b>, and a boolean state indicating whether it is active. Unlike other Pregel-like systems where a vertex object also maintains an adjacency list of items representing the out-edges with value type <b>&lt;E&gt;</b>, we choose to let users implement the adjacent list(s) in <b>&lt;V&gt;</b>. This is because in some algorithms like bi-directional BFS, we also need to maintain the in-neighbors, while in other algorithms we do not need the adjacency list at all (e.g. the <i>k</i>-means algorithm of <a href="http://dl.acm.org/citation.cfm?id=2457085" target="_blank">this paper</a>). Moreover, while <b>&lt;E&gt;</b> is required to indicate the edge length for weighted graphs, it is useless for unweighted graphs, and the adjacency list can be simply implemented as <b>std::vector&lt;I&gt;</b> to save space. In this sense, our approach is more flexible.</p>				<h4><u>Worker</u></h4>				<p>The <b>Worker</b> class takes the user-defined <b>Vertex</b> subclass as an argument, and has two abstract functions for users to specify:</p>				<div class="alert alert-info">			<p>VertexT* toVertex(char* line)</p>			<p>void toline(VertexT* v, BufferedWriter& writer)</p>		</div>				<p>The first function defines how to parse a line from the input graph data on HDFS into a vertex object. When a job runs, this function will be called for each line of the input graph data, before graph computation begins. Note that the function returns a pointer, which means that users need to call <b>new VertexT</b> in the function and set its field properly before returning it. We return <b>VertexT *</b> instead of <b>VertexT</b> to avoid the copying of a potentially large vertex object, and vertex deletion is automatically handled by our system. <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Deletion',			content: vdel_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Deletion</font></span></button>		<button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Loading',			content: vload_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Loading</font></span></button>		</p>				<p>The second function defines what to write to HDFS (using <b>BufferedWriter& writer</b>) for a processed vertex <b>VertexT* v</b>. This function is called for each vertex after the graph computation is done. <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Dumping',			content: vdump_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Dumping</font></span></button>		</p>				<h4><u>Combiner</u></h4>				<p>We assume users are familiar with the concept of message combiner. Otherwise, you may check Section 3.2 of <a href="http://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank">this paper</a>. The <b>Combiner</b> class has only one abstract function for users to specify:</p>				<div class="alert alert-info">			<p>void combine(MessageT& old_msg, MessageT& new_msg)</p>		</div>				<p>Here, <b>MessageT& old_msg</b> refers to the combined message. When a vertex in the current worker sends a message to vertex <i>tgt</i>, the system checks whether it is the first message on this worker targeted at <i>tgt</i>. If so, it becomes <b>old_msg</b>; otherwise, <b>combine(old_msg, new_msg)</b> is called to combine that message (i.e. <b>new_msg</b>) with the combined message (i.e. <b>old_msg</b>). <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Combiner Logic',			content: combiner_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Combiner</font></span></button>		</p>				<h4><u>Aggregator</u></h4>				<p>We assume users are familiar with the concept of aggregator. Otherwise, you may check Section 3.3 of <a href="http://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank">this paper</a>. The <b>Aggregator</b> class has five abstract functions for users to specify:</p>				<div class="alert alert-info">			<p>void init()</p>						<p>void stepPartial(VertexT* v)</p>						<p>void stepFinal(PartialT* p)</p>						<p>PartialT* finishPartial()</p>						<p>FinalT* finishFinal()</p>					</div>				<p>We illustrate the usage of the above functions by describing how our aggregator works. One may then check some of our application codes that use aggregator to better understand its usage.</p>				<p>&nbsp;</p>				<div align="center"><img src="figs/agg.jpg" width="560px"></img></div>				<p>&nbsp;</p>				<p>Each worker maintains an aggregator object. At the beginning of a superstep (before vertex-centric computation), the aggregator object calls <b>init()</b> to initialize its state. Then, for each vertex <b>v</b> that is active at the beginning of the superstep, <b>v.compute()</b> is first called, followed by the aggregator calling <b>stepPartial(v)</b>. In <b>stepPartial(v)</b>, the aggregator checks <b>v</b>'s state (which may already be updated by <b>v.compute()</b>) and updates its own state. Note that <b>stepPartial(v)</b> is called as long as <b>v</b> is active at the begnning of the superstep, even when <b>v</b> votes to halt in <b>compute()</b>. After vertex computation finishes, the system calls <b>finishPartial()</b> to obtain the partially aggregated state (of type <b>PartialT</b>) for each worker. This partially aggregated state is presented as the circles marked with <b>p</b> in the above figure.</p>				<p>Before the next superstep begins, the partially aggregated value <b>p</b> of each worker is sent to the master, where the master calls <b>stepFinal(PartialT* p)</b> to update the state of its aggregator with that of <b>p</b> (note that our system makes master also a worker, which processes a fraction of vertices and has its own aggregator object). After <b>stepFinal(PartialT* p)</b> is called for all partially aggregated values, the master calls <b>finishFinal()</b> to obtain the final aggregated value (i.e. the circle marked with <b>f</b> in the above figure) and broadcasts it back to each worker. If one wants to post-process the aggregated result before the next superstep, one may do that in <b>finishFinal()</b> (which is similar to the master-compute functionality of Giraph and GPS).</p>				<p>If you have many vertex states to aggregate (possibly with different logic), you may implement them as the fields of your <b>Aggregator</b> subclass and implement the abstract functions to update them properly.</p>				<p>&nbsp;</p>				<h2>(De)Serialization</h2>				<p>In a distributed system, in order to send a main-memory object to another machine, one needs to define how to map the object into its serial representation (and vice versa). The main-memory object is first <b>serialized</b> to a binary stream, which is sent to the target machine; after receiving the binary stream, the receiving machine <b>deserializes</b> the stream to obtain the main-memory object.</p>				<p>In Java-based systems such as Hadoop and Giraph, this is achieved by the <a href="https://hadoop.apache.org/docs/r1.2.1/api/org/apache/hadoop/io/Writable.html" target="_blank">Writable</a> interface. Any type of object that needs to be sent through the network should implement the Writable interface. For example, if an integer needs to be transmitted though the network, one should use <b>IntWritable</b> instead of simply using <b>int</b>.</p>				<p>In Pregel+, we are able to decouple the (de)serialization operation from the object type, thanks to C++'s support of operator overloading. Specifically, one may use any data type in their code, and if the data needs to be transmitted over the network, one needs to define the (de)serialization function for its type by overloading the operators <b><<</b> and <b>>></b>. For example, if we have a type (C/C++ basic data type, struct, or class) <b>T</b> that should be serializable, we define the following two functions:</p>				<div class="alert alert-info">			<p>obinstream& operator&gt;&gt;(obinstream& m, T& data)</p>					<p>ibinstream& operator&lt;&lt;(ibinstream& m, const T& data)</p>					</div>				<p>Here, the usage is similar to <b>cout&lt;&lt;</b> and <b>cin&gt;&gt;</b>, except that we are writing binary streams instead of text streams. We were careless during the design and the name <b>obinstream</b> and <b>ibinstream</b> are reversed from their meaning, but we leave them as they are, since revising them involves updating a lot of places throughout the system and application codes. The first function specifies how to serialize <b>data</b> to the input stream <b>m</b>, which is then sent to the target machine. The second function specifies how to deserialize the received output stream <b>m</b> to obtain the object <b>data</b>. After users define the (de)serialization operations, the system knows how to convert <b>T</b>-typed object to/from the serial data streams.</p>				<p>For basic C/C++ data types such as <b>int</b>, <b>double</b> and <b>std::string</b>, users can directly call <b>m&lt;&lt;data</b> and <b>m&gt;&gt;data</b> since they are already defined in <b>utils/serialization.h</b>. Similarly, <b>utils/serialization.h</b> also defines (de)serialization functions for STL containers such as <b>std::vector&lt;T&gt;</b> and <b>__gnu_cxx::hash_map&lt;K, V&gt;</b>. As long as the template argument(s) are serializable, the container type is serializable. For example, one can directly call <b>m&lt;&lt;data</b> for <b>data</b> of type <b>std::vector&lt;int&gt;</b> since <b>int</b> is serializable.</p>				<p>In most cases, the (de)serialization functions are called by the system rather than users. However, one may need to define the (de)serialization functions for user-defined types, where the predefined (de)serialization functions can be used in a recursive manner. For example, suppose that we have a type:</p>				<div class="alert alert-info">			<p>struct my_type</p>					<p>{</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int state;</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt; out_neighbors;</p>						<p>};</p>					</div>				<p>We may define the (de)serialization functions of <b>my_type</b> using the predefined (de)serialization functions of its components as follows: </p>		<div class="alert alert-info">			<p>obinstream& operator&gt;&gt;(obinstream& m, my_type& data)</p>					<p>{</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m &gt;&gt; state;</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m &gt;&gt; out_neighbors;</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return m;</p>						<p>}</p>						<p>&nbsp;</p>						<p>ibinstream& operator&lt;&lt;(ibinstream& m, const my_type& data)</p>					<p>{</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m &lt;&lt; state;</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m &lt;&lt; out_neighbors;</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return m;</p>						<p>}</p>					</div>				<p>We now use class <b>Vertex&lt;I, V, M&gt;</b> in <b>basic/Vertex.h</b> to illustrate what types should be serializable. If the (de)serialization functions are not defined for those types, the application code cannot pass compilation. Firstly, each vertex should be serializable, since after vertices are loaded in parallel by different workers from HDFS, they need to be exchanged though the network, so that finally each worker <b>w</b> only holds those vertices <b>v</b> with <b>hash(v) = w</b> before graph computation. In our system, the user-defined <b>Vertex</b> subclass is serializable, as long as all its template arguments <b>&lt;I&gt;</b>, <b>&lt;V&gt;</b>, <b>&lt;M&gt;</b> are serializable, which should be guaranteed by users. Secondly, since the computation is done by message passing, the message type <b>&lt;M&gt;</b> should be serializable (of course, it is already required by the first requirement just mentioned). Thirdly, if aggregator is used, a partially aggregated value of type <b>PartialT</b> should be serializable since it is sent from a worker to the master though the network; similarly, the final aggregated value of type <b>FinalT</b> should be serializable, since it is broadcast back from the master to all workers though the network.</p>				<p>&nbsp;</p>				<h2>Communication</h2>				<p>All the communication operations are handled by the system itself, and application programmers may safely skip this part. For those who would like to change or extend the system code, we provide more details <a href="communication.html" target="_blank">here</a>.</p>		<p>&nbsp;</p>				<h2>Vertex Mirroring</h2>				<p>Besides the basic mode, Pregel+ also supports the vertex-mirroring mode which is designed to cope with high degree vertices. The motivation of vertex mirroring is as follows: suppose our cluster contains 100 workers, and consider a vertex <b>v</b> with degree 1M that wants to send its state <b>a(v)</b> to all its neighbors. In the basic mode, 1M messages are sent through the network. Another option is to construct a mirror of <b>v</b> in each worker that contains <b>v</b>'s neighbors beforehand, and <b>v</b> only sends <b>a(v)</b> to all its mirrors, which then forward it to the local neighbors. At most 100 messages are sent in this case, which not only significantly reduces the number of messages, but also prevents the worker that <b>v</b> resides in from becoming a performance bottleneck.</p>				<p>However, a vertex that gets mirrored cannot enjoy the benefit of message combining, since it is not aware of the target vertex (but rather, its mirrors). Therefore, we should only construct mirrors for high degree vertices. To set the mirroring threshold, one should call the following function, which is defined in <b>utils/ghost</b>.</p>				<div class="alert alert-info">			<p>set_ghost_threshold(int degree_threshold)</p>					</div>				<p>Instead of using the <b>Vertex</b> and <b>Worker</b> classes in the <b>basic</b> package, one should use the <b>GVertex</b> and <b>GWorker</b> classes in the <b>ghost</b> package to enabling vertex mirroring. Moreover, instead of calling <b>send_message(tgt, msg)</b> to send a message to each target vertex <b>tgt</b>, a vertex <b>v</b> subclassing <b>GVertex</b> can only call <b>broadcast(msg)</b> in its <b>compute()</b> function to broadcast <b>msg</b> to its out-neighbors. Click <a href="api.html">here</a> to check the detailed programming interface.</p>				<p>&nbsp;</p>				<h2>Request-Respond API</h2>				<p>In many Pregel algorithms, a vertex <b>v</b> may need to request another vertex <b>u</b> for its state <b>a(u)</b>. Using the basic mode, <b>v</b> needs to send itself as a requester to <b>u</b>, and in the next superstep, <b>u</b> receives the request and send <b>a(u)</b> back to <b>v</b>. Therefore, <b>v</b> obtain <b>a(u)</b> in the third superstep.</p>				<p>However, the above process requires three supersteps and cumbersome coding. We provide the <b>RVertex</b> and <b>RWorker</b> classes in the <b>reqresp</b> package to facilitate the request-respond process, while all APIs of the basic mode remain valid. Specifically, the <b>RVertex</b> class provides two additional functions:</p>				<div class="alert alert-info">			<p>request(tgt)</p>						<p>RespondT get_respond(tgt)</p>					</div>				<p>Vertex <b>v</b> may now simply call <b>request(u)</b> to send request to <b>u</b>, and call <b>get_respond(u)</b> to get <a>a(u)</a> in the next superstep. However, users need to implement on more abstract function (besides <b>compute()</b>) to indicate what a vertex should respond (e.g. <b>a(u)</b>) once receiving a request:</p>				<div class="alert alert-info">			<p>RespondT respond()</p>					</div>				Another benefit of the request-respond API is that, if many vertices send request to a vertex, only one request is sent to the vertex for each worker, and the respones are also sent back to the requesting workers rather than each individual vertices.
	</div>
    <!-- /.container -->
    <!-- JavaScript -->
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-53484769-1', 'auto');ga('send', 'pageview');</script>
    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
</body>
</html>
