<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Pregel+</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">

    <!-- Add custom CSS here -->
    <style>
    body {
        margin-top: 60px;
    }
    </style>
	<script src="artDialog/artDialog.js?skin=black"></script>		<script>			(function (config) {  			config['lock'] = true;  			config['fixed'] = true;  			config['okVal'] = 'CLOSE';			// [more..]  		})(art.dialog.defaults);		var vdel_note = '<p><b>[NOTE]</b> <i><u>We use \"Implementation Note\" to discuss system implementaion details, which is of interest to people who want to change/extend the system; you may skip it if you are only interested in using the system to implement application code.</u></i></p>\		<p>Here, we briefly explain where the system deletes vertices, using the basic mode for illustration. Consider the <i>Worker</i> class in \"basic/Worker.h\", and consider the function <i>Worker::sync_graph()</i>. During data loading, each worker process reads a fraction of the input and converts the lines to vertices. However, a vertex <i>v</i> loaded by a worker <i>w<sub>i</sub></i> may have <i>hash(v) = w<sub>j</sub></i>, and thus, <i>w<sub>i</sub></i> needs to send <i>v</i> to <i>w<sub>j</sub></i> before graph computing. In other words, workers need to exchange vertices to ensure that they hold the vertices that they are responsible for. This is done by <i>Worker::sync_graph()</i>, where vertex exchange is done by the <i>all_to_all()</i> function (defined in \"utils/communication.h\") and vertices directed at other workers are deleted after being sent. Please check the function code for the details.</p>\		<p>The second place where the system deletes vertices is in the destructor of the <i>Worker</i> class. Please check the function code for the details.';		var vload_note = '<p>Here, we briefly explain how the system calls <i>Worker::toVertex(line)</i> to load the vertices. In HDFS, a graph is stored as a folder of files, where each file contains many lines each representing a vertex. During graph loading, the master will assign the files evenly to the workers, and each worker calls <i>Worker::load_graph(inpath)</i> (see \"basic/Worker.h\") for each file assigned. In <i>Worker::load_graph(inpath)</i>, the user-defined <i>toVertex(line)</i> function is called for each line of the file to parse it into a vertex object, which is appended to the worker\'s vertex set <i>Worker::vertexes</i>.</p>'		var vdump_note = '<p>Here, we briefly explain how the system calls <i>Worker::toline(v, writer)</i> to dump the vertices to HDFS. The result of a Pregel+ job is written to a user-specified output folder in HDFS, where each worker process calls <i>toline(v, writer)</i> for each vertex <i>v</i> it is responsible for, and writes the information of <i>v</i> to a file under the output folder. This is done by function <i>Worker::dump_partition(outpath)</i>. Worker <i>i</i> writes to files \"part_i_j\", where <i>j</i> = 1, 2, ... In \"utils/ydhdfs.h\", we define \"HDFS_BLOCK_SIZE\" to be 8M, and if the current file worker <i>i</i> is writing (let it be \"part_i_j\") has size exceeding \"HDFS_BLOCK_SIZE\", worker <i>i</i> creates a new file (i.e. \"part_i_(j+1)\") to write vertex information. The file splitting is automatically handled by class <i>BufferedWriter</i> defined in \"utils/ydhdfs.h\".</p>'		var combiner_note = '<p>The <i>Combiner</i> class is defined in \"utils/Combiner.h\", and the mentioned system-level message combining operation is implemented in <i>Vecs::combiner()</i> of \"utils/vecs.h\", which is called by the message buffer\'s <i>MessageBuffer::combine()</i> function defined in \"basic/MessageBuffer.h\".</p>\		<p>To achieve better performance, the actual implementation is actually a little bit different from the logic described. When vertices send messages, the messages are simply appended to the end of the message buffer; before being sent, the messages are sorted by the target vertex ID to form groups, and messages in each group are combined into one message using the specified combining function.</p>'		</script>
</head>

<body>

    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Pregel+</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="download.html">Download</a>
					</li>
					<li><a href="documentation.html">Documentation</a>
					</li>
					<li><a href="publications.html">Publications</a>
					</li>
					<li><a href="team.html">Team</a>
					</li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <div class="container">

        <div class="row">
            <div class="col-lg-12">
                <h1>Pregel+ Architecture Overview</h1>
            </div>
        </div>		<h2>Pregel+ Architecture</h2>				<p>A diagram of the architecture of Pregel+ is shown in the figure below. Pregel+ is implemented in C/C++ as a group of header files, and users only need to include the necessary base classes and implement the application logic in their subclasses. A Pregel+ application program is compiled using GCC, preferably with -O2 option enabled. Click <a href="console.html">here</a> to see how to run a Pregel+ program in your cluster.</p>		
        <p>&nbsp;</p>
        <div align="center"><img src="figs/arch.png" width="640px"></img></div>
		<p>&nbsp;</p>				<p>Pregel+ communicates with HDFS (e.g. for graph loading and result dumping) through <a href="http://hadoop.apache.org/docs/r1.2.1/libhdfs.html" target="_blank">libhdfs</a>, a JNI based C API for HDFS. Each computing unit (or, worker) of Pregel+ is simply an MPI process and communications are implemented using MPI communication primitives. One may deploy Pregel+ with any Hadoop and MPI version, such as Hadoop 1.2.1 and MPICH 3.0.4.</p>				<p>Unlike Pregel, Pregel+ also makes the master a worker, and the task of fault recovery can be implemented by a script as follows. The script loops a Pregel+ job, which runs for at most Î” supersteps before dumping the intermediate results to HDFS. Meanwhile, the script also monitors the cluster condition. If a machine is down, the script kills the current job and restarts another job loading the latest intermediate results from HDFS. Fault tolerance is achieved by the data replication in HDFS.</p>		<p>&nbsp;</p>				<h2>User-Defined Classes</h2>				<p>In this web page, we just provide a high-level description of Pregel+'s base classes. Users need to subclass them with their template arguments properly specified in the application code. Click <a href="api.html">here</a> to check the detailed programming interface.</p>				<h3>Vertex</h3>				<p>The <b>Vertex</b> class has an abstract <b>compute()</b> function, where users implement their vertex-centric computing logic. An <b>Vertex</b> object maintains three fields: a vertex ID of type <b>&lt;I&gt;</b>, a vertex value type <b>&lt;V&gt;</b>, and a boolean state indicating whether it is active. Unlike other Pregel-like systems where a vertex object also maintains an adjacency list of items representing the out-edges with value type <b>&lt;E&gt;</b>, we choose to let users implement the adjacent list(s) in <b>&lt;V&gt;</b>. This is because in some algorithms like bi-directional BFS, we also need to maintain the in-neighbors, while in other algorithms we do not need the adjacency list at all (e.g. the <i>k</i>-means algorithm of <a href="http://dl.acm.org/citation.cfm?id=2457085" target="_blank">this paper</a>). Moreover, while <b>&lt;E&gt;</b> is required to indicate the edge length for weighted graphs, it is useless for unweighted graphs, and the adjacency list can be simply implemented as <b>std::vector&lt;I&gt;</b> to save space. In this sense, our approach is more flexible.</p>				<h3>Worker</h3>				<p>The <b>Worker</b> class takes the user-defined <b>Vertex</b> subclass as an argument, and has two abstract functions for users to specify:</p>				<div class="alert alert-info">			<p>VertexT* toVertex(char* line)</p>			<p>void toline(VertexT* v, BufferedWriter& writer)</p>		</div>				<p>The first function defines how to parse a line from the input graph data on HDFS into a vertex object. When a job runs, this function will be called for each line of the input graph data, before graph computation begins. Note that the function returns a pointer, which means that users need to call <b>new VertexT</b> in the function and set its field properly before returning it. We return <b>VertexT *</b> instead of <b>VertexT</b> to avoid the copying of a potentially large vertex object, and vertex deletion is automatically handled by our system. <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Deletion',			content: vdel_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Deletion</font></span></button>		<button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Loading',			content: vload_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Loading</font></span></button>		</p>				<p>The second function defines what to write to HDFS (using <b>BufferedWriter& writer</b>) for a processed vertex <b>VertexT* v</b>. This function is called for each vertex after the graph computation is done. <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Vertex Dumping',			content: vdump_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Vertex_Dumping</font></span></button>		</p>				<h3>Combiner</h3>				<p>We assume users are familiar with the concept of message combiner. Otherwise, you may check Section 3.2 of <a href="http://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank">this paper</a>. The <b>Combiner</b> class has only one abstract function for users to specify:</p>				<div class="alert alert-info">			<p>void combine(MessageT& old_msg, MessageT& new_msg)</p>		</div>				<p>Here, <b>MessageT& old_msg</b> refers to the combined message. When a vertex in the current worker sends a message to vertex <i>tgt</i>, the system checks whether it is the first message on this worker targeted at <i>tgt</i>. If so, it becomes <b>old_msg</b>; otherwise, <b>combine(old_msg, new_msg)</b> is called to combine that message (i.e. <b>new_msg</b>) with the combined message (i.e. <b>old_msg</b>). <button type="button" class="btn btn-default btn-xs" onclick="art.dialog({			width: '50%',			title: 'Implementation Note on Combiner Logic',			content: combiner_note,			ok: function(){return true;}		});"><span class="glyphicon glyphicon-zoom-in"><font size="3px" color="blue">_Note_on_Combiner</font></span></button>		</p>				<h3>Aggregator</h3>				<p>We assume users are familiar with the concept of aggregator. Otherwise, you may check Section 3.3 of <a href="http://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank">this paper</a>. The <b>Aggregator</b> class has five abstract functions for users to specify:</p>				<div class="alert alert-info">			<p>void init()</p>						<p>void stepPartial(VertexT* v)</p>						<p>void stepFinal(PartialT* p)</p>						<p>PartialT* finishPartial()</p>						<p>FinalT* finishFinal()</p>					</div>				<p>We illustrate the usage of the above functions by describing how our aggregator works. One may then check some of our application codes that use aggregator to better understand its usage.</p>				<p>&nbsp;</p>				<div align="center"><img src="figs/agg.jpg" width="560px"></img></div>				<p>&nbsp;</p>				<p>Each worker maintains an aggregator object. At the beginning of a superstep (before vertex-centric computation), the aggregator object calls <b>init()</b> to initialize its state. Then, for each vertex <b>v</b> that is active at the beginning of the superstep, <b>v.compute()</b> is first called, followed by the aggregator calling <b>stepPartial(v)</b>. In <b>stepPartial(v)</b>, the aggregator checks <b>v</b>'s state (which may already be updated by <b>v.compute()</b>) and updates its own state. Note that <b>stepPartial(v)</b> is called as long as <b>v</b> is active at the begnning of the superstep, even when <b>v</b> votes to halt in <b>compute()</b>. After vertex computation finishes, the system calls <b>finishPartial()</b> to obtain the partially aggregated state (of type <b>PartialT</b>) for each worker. This partially aggregated state is presented as the circles marked with <b>p</b> in the above figure.</p>				<p>Before the next superstep begins, the partially aggregated value <b>p</b> of each worker is sent to the master, where the master calls <b>stepFinal(PartialT* p)</b> to update the state of its aggregator with that of <b>p</b> (note that our system makes master also a worker, which processes a fraction of vertices and has its own aggregator object). After <b>stepFinal(PartialT* p)</b> is called for all partially aggregated values, the master calls <b>finishFinal()</b> to obtain the final aggregated value (i.e. the circle marked with <b>f</b> in the above figure) and broadcasts it back to each worker. If one wants to post-process the aggregated result before the next superstep, one may do that in <b>finishFinal()</b> (which is similar to the master-compute functionality of Giraph and GPS).</p>				<p>If you have many vertex states to aggregate (possibly with different logic), you may implement them as the fields of your <b>Aggregator</b> subclass and implement the abstract functions to update them properly.</p>				<p>&nbsp;</p>				<h2>(De)Serialization</h2>				<p>....</p>
	</div>
    <!-- /.container -->
    <!-- JavaScript -->
    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
</body>
</html>
